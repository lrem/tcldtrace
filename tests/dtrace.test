#!/usr/bin/tclsh

if {[lsearch [namespace children] ::tcltest] == -1} {
	package require tcltest 2.2
	namespace import ::tcltest::*
}

testConstraint tcl85 [package vsatisfies [package present Tcl] 8.5]

package require dtrace

# Tests not requiring root {{{

# {{{ ::dtrace::open

test "open-1.1" "bad value for instrument" -body {
	::dtrace::open abc
} -returnCodes {1} -result {expected boolean value but got "abc"
::dtrace::open bad usage}

test "open-1.2" "bad option name" -body {
	::dtrace::open -fooshmoo 1 0
} -returnCodes {1} -result {::dtrace::open bad option initialization -fooshmoo}

test "open-1.3" "bad option value" -body {
	::dtrace::open -bufsize abc 0
} -returnCodes {1} -result {::dtrace::open bad option initialization -bufsize}

# }}}

# ::dtrace::close {{{

test "close-1.1" "too few arguments for close" -body {
	::dtrace::close
} -returnCodes {1} -result {wrong # args: should be "::dtrace::close handle"}

test "close-1.2" "too much arguments for close" -body {
	::dtrace::close abc def
} -returnCodes {1} -result {wrong # args: should be "::dtrace::close handle"}

test "close-1.3" "closing invalid handle" -body {
	::dtrace::close 1
} -returnCodes {1} -result {::dtrace::close bad handle}

# }}}

# ::dtrace::configure {{{

test "configure-1.1" "too few arguments for configure" -body {
	::dtrace::configure
} -returnCodes {1} -result {wrong # args: should be "::dtrace::configure handle ?option value ...?"}

test "configure-1.2" "too much arguments for configure" -body {
	::dtrace::configure abc -bufsize 1 abc
} -returnCodes {1} -result {wrong # args: should be "::dtrace::configure handle ?option value ...?"}

test "configure-1.3" "configuring invalid handle" -body {
	::dtrace::configure 0 -bufsize 1
} -returnCodes {1} -result {::dtrace::configure bad handle}

# }}}

# ::dtrace::compile {{{

test "compile-1.1" "too few arguments for compile" -body {
	::dtrace::compile
} -returnCodes {1} -result {wrong # args: should be "::dtrace::compile handle program ?{argument0 argument1 ...}?"}

test "compile-1.2" "compiling with invalid handle" -body {
	::dtrace::compile 0 {:::entry}
} -returnCodes {1} -result {::dtrace::compile bad handle}

test "compile-1.3" "successful compiling" -setup {
	set h [::dtrace::open 0]
} -body {
	::dtrace::compile $h {:::entry}
} -cleanup {
	::dtrace::close $h
} -result {1}

# }}}

# ::dtrace::exec {{{

test "exec-1.1" "too few arguments for exec" -body {
	::dtrace::exec
} -returnCodes {1} \
-result {wrong # args: should be "::dtrace::exec compiled_program"}

test "exec-1.2" "too much much for exec" -body {
	::dtrace::exec a b c
} -returnCodes {1} \
-result {wrong # args: should be "::dtrace::exec compiled_program"}

test "exec-1.4" "exec with invalid program" -body {
	::dtrace::exec -1
} -returnCodes {1} -result {::dtrace::exec bad program handle}

test "exec-1.5" "exec with non-instrumenting handle" -setup {
	set h [::dtrace::open 0]
	set p [::dtrace::compile $h {:::entry}]
} -body {
	::dtrace::exec $p
} -cleanup {
	::dtrace::close $h
} -returnCodes {1} -result {::dtrace::exec failed enable the probe}

# }}}

# ::dtrace::info {{{

test "info-1.1" "too few arguments for info" -body {
	::dtrace::info
} -returnCodes {1} \
-result {wrong # args: should be "::dtrace::info compiled_program"}

test "info-1.2" "too few much for info" -body {
	::dtrace::info a b c
} -returnCodes {1} \
-result {wrong # args: should be "::dtrace::info compiled_program"}

test "info-1.4" "info with invalid program" -body {
	::dtrace::info -1
} -returnCodes {1} -result {::dtrace::info bad program handle}

test "info-1.5" "info for BEGIN" -setup {
	set h [::dtrace::open 0]
	set p [::dtrace::compile $h {:::BEGIN}]
} -body {
	::dtrace::info $p
} -cleanup {
	::dtrace::close $h
} -result {aggregates 0 recgens 1 matches 0 speculations 0}

# }}}

# ::dtrace::go {{{

test "go-1.1" "too few arguments for go" -body {
	::dtrace::go
} -returnCodes {1} -result \
{wrong # args: should be "::dtrace::go handle ?callback {proc ?args?} ...?"}

test "go-1.2" "go with callback name and no proc" -body {
	::dtrace::go $h probe_output
} -returnCodes {1} -result \
{wrong # args: should be "::dtrace::go handle ?callback {proc ?args?} ...?"}


test "go-1.3" "go with invalid handle" -body {
	::dtrace::go -1
} -returnCodes {1} -result {::dtrace::go bad handle}

test "go-1.4" "go with invalid callback" -setup {
	set h [::dtrace open 0]
} -body {
	::dtrace::go $h fooshmoo {cb_fooshmoo {arg0 arg1}}
} -cleanup {
	::dtrace::close $h
} -returnCodes {1} -result {bad callback name "fooshmoo":\
must be probe_desc, probe_output, drop, error, or proc}

test "go-1.5" "go without args for callback" -setup {
	set h [::dtrace::open 0]
} -body {
	::dtrace::go $h probe_output {cb_probe_output}
} -cleanup {
	::dtrace::close $h
} -returnCodes {1} -result "callback spec should be {proc {?arg0 arg1 ...?}}"
# I know that "" stands out here, but it was breaking the folds

test "go-1.6" "go with non-instrumenting handle" -setup {
	set h [::dtrace::open 0]
} -body {
	::dtrace::go $h
} -cleanup {
	::dtrace::close $h
} -returnCodes {1} -result {::dtrace::go libdtrace error: Bad file number}

# }}}

# ::dtrace::stop {{{

test "stop-1.1" "too few arguments for stop" -body {
	::dtrace::stop
} -returnCodes {1} -result {wrong # args: should be "::dtrace::stop handle"}

test "stop-1.2" "too much arguments for stop" -body {
	::dtrace::stop a b c
} -returnCodes {1} -result {wrong # args: should be "::dtrace::stop handle"}

test "stop-1.3" "stop on invalid handle" -body {
	::dtrace::stop -1
} -returnCodes {1} -result {::dtrace::stop bad handle}

test "stop-1.4" "stop on non-instrumenting handle" -setup {
	set h [::dtrace::open 0]
} -body {
	::dtrace::stop $h
} -cleanup {
	::dtrace::close $h
} -returnCodes {1} -result {::dtrace::stop libdtrace error: Bad file number}

# }}}

# Ensemble test {{{
test "ensemble-1.3" "looking for ensemble" -constraints {tcl85} -body {
	dtrace close
} -returnCodes {1} -result {wrong # args: should be "dtrace close handle"}

# }}}

# Simple scripts, no output {{{

test "simplescripts-1.1" "opening and closing" -body {
	set h [::dtrace::open 0]
	::dtrace::close $h
}

test "simplescripts-1.2" "opening and double closing" -body {
	set h [::dtrace::open 0]
	::dtrace::close $h
	::dtrace::close $h
} -returnCodes {1} -result {::dtrace::close bad handle}

test "simplescripts-2.1" "configuring" -body {
	set h [::dtrace::open -bufsize 123 0]
	set b [::dtrace::configure $h -bufsize]
	::dtrace::close $h
	return [expr {$b == 123}]
} -result {1}

test "simplescripts-2.2" "configuring" -body {
	set h [::dtrace::open -bufsize 123 0]
	::dtrace::configure $h -bufsize 321
	set b [::dtrace::configure $h -bufsize]
	::dtrace::close $h
	return [expr {$b == 321}]
} -result {1}

test "simplescripts-2.3" "configuring" -body {
	set h [::dtrace::open -bufsize 123 0]
	catch {::dtrace::configure $h -bufsize 321 -fooshmoo 3}
	set b [::dtrace::configure $h -bufsize]
	::dtrace::close $h
	return [expr {$b == 321}]
} -result {1}



# }}}

# }}}

# Tests requiring root {{{

# ::dtrace::exec {{{
test "exec-2.1" "exec for BEGIN" -setup {
	set h [::dtrace::open]
	set p [::dtrace::compile $h {:::BEGIN}]
} -body {
	::dtrace::exec $p
} -cleanup {
	::dtrace::close $h
} -result {aggregates 0 recgens 1 matches 1 speculations 0}


test "exec-2.2" "entries count" -setup {
	set h [::dtrace::open]
	set p [::dtrace::compile $h {:::entry}]
} -body {
	lindex [::dtrace::exec $p] 5
} -cleanup {
	::dtrace::close $h
} -match regexp -result {[1-9][0-9]+}  
# Multiple matches

# }}}

# ::dtrace::go {{{

test "go-2.1" "simply go" -setup {
	set h [::dtrace open]
} -body {
	::dtrace::go $h
} -cleanup {
	::dtrace::close $h
} 

test "go-2.2" "go and register all callbacks" -setup {
	set h [::dtrace open]
} -body {
	::dtrace::go $h probe_desc {cb_probe_desc {arg0 arg1}} \
	probe_output {cb_probe_output {arg0}} drop {cb_drop {}} \
	error {cb_error {}} proc {cp_proc {arg0 arg1 arg2 arg3}}
} -cleanup {
	::dtrace::close $h
}

# }}}

# ::dtrace::stop {{{

test "stop-2.1" "stop on non-running handle" -setup {
	set h [::dtrace open]
} -body {
	::dtrace::stop $h
} -cleanup {
	::dtrace::close $h
} -returnCodes {1} -result {::dtrace::stop libdtrace error: Invalid argument}

test "stop-2.2" "simply stop" -setup {
	set h [::dtrace open]
	::dtrace::go $h
} -body {
	::dtrace::stop $h
} -cleanup {
	::dtrace::close $h
}

# }}}

# }}}

cleanupTests

# vim: set foldmethod=marker:
